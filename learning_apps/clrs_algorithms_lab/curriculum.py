"""
Curriculum: Introduction to Algorithms (CLRS) — Cormen, Leiserson, Rivest, Stein.
DP, Greedy, Graph, Data Structures.
"""
from typing import Dict, Any, List

LEVELS = ["basics", "intermediate", "advanced", "expert"]

BOOKS = [
    {"id": "clrs_dp", "name": "CLRS Dynamic Programming", "short": "Ch 15 DP", "color": "#2563eb"},
    {"id": "clrs_greedy", "name": "CLRS Greedy", "short": "Ch 16 Greedy", "color": "#059669"},
    {"id": "clrs_graph", "name": "CLRS Graph Algorithms", "short": "Ch 22-26 Graph", "color": "#7c3aed"},
    {"id": "clrs_data_structures", "name": "Advanced Data Structures", "short": "Ch 6,11-13,18", "color": "#dc2626"},
    {"id": "clrs_complexity", "name": "NP-Completeness", "short": "Ch 34-35", "color": "#f59e0b"},
]

CURRICULUM: List[Dict[str, Any]] = [
    # DYNAMIC PROGRAMMING (8)
    {"id": "clrs_coin", "book_id": "clrs_dp", "level": "basics", "title": "Coin Change (Min Coins)", "learn": "DP: min coins to make amount. dp[i] = min over coins of 1 + dp[i-coin]. Reconstruct combination. Classic intro to DP with optimal substructure.", "try_code": "from clrs_complete_algorithms import CLRSDynamicProgramming\ncoins = [1, 3, 4]; amount = 6\nn, combo = CLRSDynamicProgramming.coin_change_min_coins(coins, amount)\nprint(f'Min coins for {amount}: {n}, combination: {combo}')", "try_demo": "clrs_coin", "prerequisites": []},
    {"id": "clrs_rod", "book_id": "clrs_dp", "level": "intermediate", "title": "Rod Cutting (Ch 15.1)", "learn": "Maximize profit by cutting rod. prices[i] = price for length i+1. DP: R[n] = max(prices[i] + R[n-i-1]). First DP problem in CLRS demonstrating optimal substructure.", "try_code": "from clrs_complete_algorithms import CLRSDynamicProgramming\nprices = [1, 5, 8, 9, 10, 17, 17, 20]; length = 8\nprofit, cuts = CLRSDynamicProgramming.rod_cutting(prices, length)\nprint(f'Max profit: {profit}, cuts at positions: {cuts}')", "try_demo": "clrs_rod", "prerequisites": ["clrs_coin"]},
    {"id": "clrs_matrix_chain", "book_id": "clrs_dp", "level": "intermediate", "title": "Matrix Chain Multiplication (Ch 15.2)", "learn": "Find optimal parenthesization to minimize scalar multiplications. DP on subproblems [i,j]. Classic example of O(n³) DP with 2D table.", "try_code": "def matrix_chain_order(dims):\n    n = len(dims) - 1; m = [[0] * n for _ in range(n)]; s = [[0] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1; m[i][j] = float('inf')\n            for k in range(i, j):\n                cost = m[i][k] + m[k+1][j] + dims[i]*dims[k+1]*dims[j+1]\n                if cost < m[i][j]: m[i][j] = cost; s[i][j] = k\n    return m[0][n-1], s\ndims = [10, 100, 5, 50]\nmin_cost, splits = matrix_chain_order(dims)\nprint(f'Min multiplications: {min_cost}')", "try_demo": None, "prerequisites": ["clrs_rod"]},
    {"id": "clrs_lcs", "book_id": "clrs_dp", "level": "intermediate", "title": "Longest Common Subsequence (Ch 15.4)", "learn": "Find longest subsequence common to two sequences. DP: if X[i]=Y[j], LCS[i][j] = 1+LCS[i-1][j-1], else max(LCS[i-1][j], LCS[i][j-1]). Applications: diff, bioinformatics.", "try_code": "def lcs_length(X, Y):\n    m, n = len(X), len(Y); c = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if X[i-1] == Y[j-1]: c[i][j] = c[i-1][j-1] + 1\n            else: c[i][j] = max(c[i-1][j], c[i][j-1])\n    return c[m][n]\nX, Y = 'ABCBDAB', 'BDCABA'\nprint(f'LCS length: {lcs_length(X, Y)}')", "try_demo": None, "prerequisites": ["clrs_matrix_chain"]},
    {"id": "clrs_obst", "book_id": "clrs_dp", "level": "advanced", "title": "Optimal BST (Ch 15.5)", "learn": "Build binary search tree with minimum expected search cost given key frequencies. DP on root choices for each subrange [i,j]. More complex: uses 3 tables (e, w, root).", "try_code": "from clrs_complete_algorithms import CLRSDynamicProgramming\nkeys = ['A', 'B', 'C']; freq = [0.5, 0.3, 0.2]\ncost, root = CLRSDynamicProgramming.optimal_binary_search_tree(keys, freq)\nprint(f'Min expected cost: {cost}, root structure: {root}')", "try_demo": "clrs_obst", "prerequisites": ["clrs_lcs"]},
    {"id": "clrs_lis", "book_id": "clrs_dp", "level": "intermediate", "title": "Longest Increasing Subsequence", "learn": "DP: dp[i] = length of LIS ending at i. Reconstruct via parent pointers. O(n²); can optimize to O(n log n) with binary search + patience sorting algorithm.", "try_code": "from clrs_complete_algorithms import CLRSDynamicProgramming\narr = [10, 22, 9, 33, 21, 50, 41, 60]\nlength, indices = CLRSDynamicProgramming.longest_increasing_subsequence(arr)\nprint(f'LIS length: {length}, indices: {indices}')", "try_demo": "clrs_lis", "prerequisites": ["clrs_lcs"]},
    {"id": "clrs_edit_distance", "book_id": "clrs_dp", "level": "advanced", "title": "Edit Distance (Levenshtein)", "learn": "Minimum operations (insert, delete, substitute) to transform one string to another. DP: if chars match, dp[i][j]=dp[i-1][j-1], else 1+min(insert, delete, substitute).", "try_code": "def edit_distance(s1, s2):\n    m, n = len(s1), len(s2); dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1): dp[i][0] = i\n    for j in range(n + 1): dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1]\n            else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    return dp[m][n]\nprint(edit_distance('kitten', 'sitting'))", "try_demo": None, "prerequisites": ["clrs_lcs"]},
    {"id": "clrs_knapsack", "book_id": "clrs_dp", "level": "advanced", "title": "0/1 Knapsack", "learn": "Select items to maximize value subject to weight constraint. DP: K[i][w] = max(K[i-1][w], value[i] + K[i-1][w-weight[i]]). Pseudo-polynomial O(nW).", "try_code": "def knapsack_01(weights, values, capacity):\n    n = len(weights); dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(dp[i-1][w], values[i-1] + dp[i-1][w - weights[i-1]])\n            else: dp[i][w] = dp[i-1][w]\n    return dp[n][capacity]\nweights = [10, 20, 30]; values = [60, 100, 120]\nprint(f'Max value: {knapsack_01(weights, values, 50)}')", "try_demo": None, "prerequisites": ["clrs_obst"]},
    
    # GREEDY (6)
    {"id": "clrs_activity", "book_id": "clrs_greedy", "level": "basics", "title": "Activity Selection (Ch 16.1)", "learn": "Schedule maximum number of non-overlapping activities. Greedy: pick earliest finish time, then next compatible. Proves greedy choice property and optimal substructure.", "try_code": "def activity_selection(start, finish):\n    activities = sorted(zip(start, finish), key=lambda x: x[1]); selected = [activities[0]]\n    for s, f in activities[1:]:\n        if s >= selected[-1][1]: selected.append((s, f))\n    return selected\nstart = [1, 3, 0, 5, 8, 5]; finish = [2, 4, 6, 7, 9, 9]\nprint(f'Selected activities: {activity_selection(start, finish)}')", "try_demo": None, "prerequisites": []},
    {"id": "clrs_huffman", "book_id": "clrs_greedy", "level": "intermediate", "title": "Huffman Coding (Ch 16.3)", "learn": "Optimal prefix-free binary encoding. Greedy: merge two least-frequent symbols. Build tree bottom-up. Applications: compression, information theory.", "try_code": "import heapq\nclass HuffmanNode:\n    def __init__(self, char, freq, left=None, right=None):\n        self.char = char; self.freq = freq; self.left = left; self.right = right\n    def __lt__(self, other): return self.freq < other.freq\ndef huffman_coding(freq_dict):\n    heap = [HuffmanNode(char, freq) for char, freq in freq_dict.items()]\n    heapq.heapify(heap)\n    while len(heap) > 1:\n        left = heapq.heappop(heap); right = heapq.heappop(heap)\n        heapq.heappush(heap, HuffmanNode(None, left.freq + right.freq, left, right))\n    return heap[0]\nfreq = {'a': 45, 'b': 13, 'c': 12, 'd': 16, 'e': 9, 'f': 5}\nroot = huffman_coding(freq)", "try_demo": None, "prerequisites": ["clrs_activity"]},
    {"id": "clrs_fractional_knapsack", "book_id": "clrs_greedy", "level": "basics", "title": "Fractional Knapsack", "learn": "Allow fractional items (unlike 0/1). Greedy: sort by value/weight ratio, take items in order. O(n log n). Shows greedy works here but not for 0/1 variant.", "try_code": "def fractional_knapsack(weights, values, capacity):\n    items = [(v/w, w, v) for w, v in zip(weights, values)]; items.sort(reverse=True)\n    total_value = 0\n    for ratio, weight, value in items:\n        if capacity >= weight: capacity -= weight; total_value += value\n        else: total_value += ratio * capacity; break\n    return total_value\nweights = [10, 20, 30]; values = [60, 100, 120]\nprint(fractional_knapsack(weights, values, 50))", "try_demo": None, "prerequisites": ["clrs_activity"]},
    {"id": "clrs_prim", "book_id": "clrs_greedy", "level": "intermediate", "title": "Prim's MST (Ch 23.2)", "learn": "Grow minimum spanning tree from a start vertex. Use min-heap for next edge. O(E log V) with binary heap. Greedy: add minimum weight edge connecting tree to non-tree vertex.", "try_code": "import heapq\ndef prim_mst(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v, w in edges: graph[u].append((v, w)); graph[v].append((u, w))\n    mst = []; visited = [False] * n; min_heap = [(0, 0, -1)]\n    while min_heap:\n        weight, u, parent = heapq.heappop(min_heap)\n        if visited[u]: continue\n        visited[u] = True\n        if parent != -1: mst.append((parent, u, weight))\n        for v, w in graph[u]:\n            if not visited[v]: heapq.heappush(min_heap, (w, v, u))\n    return mst, sum(w for _, _, w in mst)\nedges = [(0,1,4), (0,7,8), (1,2,8)]\nmst, total_weight = prim_mst(9, edges)\nprint(f'MST weight: {total_weight}')", "try_demo": None, "prerequisites": ["clrs_huffman"]},
    {"id": "clrs_kruskal", "book_id": "clrs_greedy", "level": "intermediate", "title": "Kruskal's MST (Ch 23.2)", "learn": "Build MST by adding edges in weight order, avoiding cycles. Use union-find (disjoint sets). O(E log E) for sorting. Alternative to Prim's with different data structure emphasis.", "try_code": "class UnionFind:\n    def __init__(self, n): self.parent = list(range(n)); self.rank = [0] * n\n    def find(self, x):\n        if self.parent[x] != x: self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x == root_y: return False\n        if self.rank[root_x] < self.rank[root_y]: self.parent[root_x] = root_y\n        else: self.parent[root_y] = root_x; self.rank[root_x] += (self.rank[root_x] == self.rank[root_y])\n        return True\ndef kruskal_mst(n, edges):\n    edges.sort(key=lambda x: x[2]); uf = UnionFind(n); mst = []\n    for u, v, w in edges:\n        if uf.union(u, v): mst.append((u, v, w))\n    return mst, sum(w for _, _, w in mst)", "try_demo": None, "prerequisites": ["clrs_prim"]},
    {"id": "clrs_task_scheduling", "book_id": "clrs_greedy", "level": "advanced", "title": "Task Scheduling with Deadlines", "learn": "Maximize profit by scheduling tasks with deadlines and penalties. Greedy: sort by penalty/profit, schedule in latest available slot. Uses disjoint set for slot management.", "try_code": "def task_scheduling(tasks, max_deadline):\n    tasks.sort(reverse=True); slots = [-1] * (max_deadline + 1); total_profit = 0; scheduled = []\n    for profit, deadline in tasks:\n        for t in range(min(deadline, max_deadline), 0, -1):\n            if slots[t] == -1:\n                slots[t] = profit; total_profit += profit; scheduled.append((profit, deadline, t)); break\n    return total_profit, scheduled\ntasks = [(100, 2), (10, 1), (15, 2), (27, 1)]\nprofit, schedule = task_scheduling(tasks, 2)\nprint(f'Max profit: {profit}')", "try_demo": None, "prerequisites": ["clrs_kruskal"]},
    
    # GRAPH (9)
    {"id": "clrs_bfs", "book_id": "clrs_graph", "level": "basics", "title": "Breadth-First Search (Ch 22.2)", "learn": "Explore graph level-by-level using queue. Finds shortest paths in unweighted graphs. O(V+E). Produces BFS tree with parent pointers and distances.", "try_code": "from collections import deque\ndef bfs(graph, start):\n    visited = {start}; queue = deque([(start, 0)]); distances = {start: 0}; parent = {start: None}\n    while queue:\n        u, dist = queue.popleft()\n        for v in graph[u]:\n            if v not in visited:\n                visited.add(v); distances[v] = dist + 1; parent[v] = u; queue.append((v, dist + 1))\n    return distances, parent\ngraph = {0: [1, 2], 1: [2], 2: [3], 3: [1]}\nprint(f'Distances from 0: {bfs(graph, 0)[0]}')", "try_demo": None, "prerequisites": []},
    {"id": "clrs_dfs", "book_id": "clrs_graph", "level": "basics", "title": "Depth-First Search (Ch 22.3)", "learn": "Explore graph deeply before backtracking. Discovers discovery/finish times. Produces DFS forest. Applications: topological sort, SCC, cycle detection. O(V+E).", "try_code": "def dfs(graph, start, visited=None):\n    if visited is None: visited = set()\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited: dfs(graph, neighbor, visited)\n    return visited\ngraph = {0: [1, 2], 1: [2], 2: [3], 3: [1]}\nprint(f'DFS from 0: {dfs(graph, 0)}')", "try_demo": None, "prerequisites": ["clrs_bfs"]},
    {"id": "clrs_topological_sort", "book_id": "clrs_graph", "level": "intermediate", "title": "Topological Sort (Ch 22.4)", "learn": "Linear ordering of DAG vertices where edge (u,v) → u before v. DFS-based: output vertices in reverse finish time. Applications: build systems, course scheduling. O(V+E).", "try_code": "def topological_sort(graph):\n    visited = set(); stack = []\n    def dfs(u):\n        visited.add(u)\n        for v in graph.get(u, []):\n            if v not in visited: dfs(v)\n        stack.append(u)\n    for vertex in graph:\n        if vertex not in visited: dfs(vertex)\n    return stack[::-1]\ngraph = {'Linear Algebra': [], 'Calculus': [], 'Probability': ['Calculus'], 'ML': ['Linear Algebra', 'Probability'], 'Deep Learning': ['ML']}\nprint(f'Course order: {topological_sort(graph)}')", "try_demo": None, "prerequisites": ["clrs_dfs"]},
    {"id": "clrs_scc", "book_id": "clrs_graph", "level": "advanced", "title": "Strongly Connected Components (Ch 22.5)", "learn": "Maximal sets where every vertex reaches every other. Kosaraju's algorithm: DFS on G, then DFS on G^T in reverse finish order. O(V+E). Applications: web graph analysis.", "try_code": "def kosaraju_scc(graph):\n    visited = set(); stack = []\n    def dfs1(u):\n        visited.add(u)\n        for v in graph.get(u, []):\n            if v not in visited: dfs1(v)\n        stack.append(u)\n    for vertex in graph:\n        if vertex not in visited: dfs1(vertex)\n    transpose = {}\n    for u in graph:\n        for v in graph[u]:\n            if v not in transpose: transpose[v] = []\n            transpose[v].append(u)\n    visited = set(); sccs = []\n    def dfs2(u, component):\n        visited.add(u); component.append(u)\n        for v in transpose.get(u, []):\n            if v not in visited: dfs2(v, component)\n    while stack:\n        u = stack.pop()\n        if u not in visited: component = []; dfs2(u, component); sccs.append(component)\n    return sccs\ngraph = {0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3]}\nprint(f'SCCs: {kosaraju_scc(graph)}')", "try_demo": None, "prerequisites": ["clrs_topological_sort"]},
    {"id": "clrs_dijkstra", "book_id": "clrs_graph", "level": "intermediate", "title": "Dijkstra's Algorithm (Ch 24.3)", "learn": "Single-source shortest paths with non-negative weights. Greedy: extract min distance vertex, relax neighbors. O(V²) naive, O((V+E) log V) with min-heap.", "try_code": "import heapq\ndef dijkstra(graph, start):\n    distances = {v: float('inf') for v in graph}; distances[start] = 0; parent = {v: None for v in graph}; pq = [(0, start)]\n    while pq:\n        dist, u = heapq.heappop(pq)\n        if dist > distances[u]: continue\n        for v, weight in graph[u]:\n            new_dist = distances[u] + weight\n            if new_dist < distances[v]:\n                distances[v] = new_dist; parent[v] = u; heapq.heappush(pq, (new_dist, v))\n    return distances, parent\ngraph = {'A': [('B', 1), ('C', 4)], 'B': [('C', 2), ('D', 5)], 'C': [('D', 1)], 'D': []}\nprint(f'Shortest distances: {dijkstra(graph, \"A\")[0]}')", "try_demo": None, "prerequisites": ["clrs_bfs"]},
    {"id": "clrs_bellman", "book_id": "clrs_graph", "level": "advanced", "title": "Bellman-Ford (Ch 24.1)", "learn": "Single-source shortest paths with negative edge weights. Relax all edges V-1 times. Detects negative cycles. O(VE). More general than Dijkstra but slower.", "try_code": "def bellman_ford(vertices, edges, start):\n    distances = {v: float('inf') for v in vertices}; distances[start] = 0; parent = {v: None for v in vertices}\n    for _ in range(len(vertices) - 1):\n        for u, v, weight in edges:\n            if distances[u] + weight < distances[v]: distances[v] = distances[u] + weight; parent[v] = u\n    for u, v, weight in edges:\n        if distances[u] + weight < distances[v]: return None, 'Negative cycle detected'\n    return distances, parent\nvertices = ['A', 'B', 'C', 'D']; edges = [('A','B',1), ('B','C',3), ('A','C',4), ('C','D',-2)]\nprint(f'Distances: {bellman_ford(vertices, edges, \"A\")[0]}')", "try_demo": None, "prerequisites": ["clrs_dijkstra"]},
    {"id": "clrs_floyd_warshall", "book_id": "clrs_graph", "level": "advanced", "title": "Floyd-Warshall (Ch 25.2)", "learn": "All-pairs shortest paths. DP: consider paths through vertices 1..k. D[i][j][k] = min(D[i][j][k-1], D[i][k][k-1] + D[k][j][k-1]). O(V³). Handles negative weights, detects cycles.", "try_code": "def floyd_warshall(vertices, edges):\n    n = len(vertices); dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n): dist[i][i] = 0\n    for u, v, w in edges: dist[u][v] = w\n    for k in range(n):\n        for i in range(n):\n            for j in range(n): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    for i in range(n):\n        if dist[i][i] < 0: return None, 'Negative cycle'\n    return dist\nedges = [(0,1,3), (1,2,1), (2,0,-3), (0,2,5)]\nprint(f'All-pairs distances: {floyd_warshall(3, edges)}')", "try_demo": None, "prerequisites": ["clrs_bellman"]},
    {"id": "clrs_max_flow", "book_id": "clrs_graph", "level": "advanced", "title": "Ford-Fulkerson Max Flow (Ch 26.2)", "learn": "Maximum flow from source to sink in flow network. Find augmenting paths until none exist. Capacity constraints. Applications: bipartite matching, network routing. O(E|f*|) where f* is max flow.", "try_code": "from collections import deque\ndef ford_fulkerson(graph, source, sink):\n    def bfs(source, sink, parent):\n        visited = {source}; queue = deque([source])\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                if v not in visited and graph[u][v] > 0:\n                    visited.add(v); parent[v] = u\n                    if v == sink: return True\n                    queue.append(v)\n        return False\n    parent = {}; max_flow = 0\n    while bfs(source, sink, parent):\n        path_flow = float('inf'); s = sink\n        while s != source: path_flow = min(path_flow, graph[parent[s]][s]); s = parent[s]\n        v = sink\n        while v != source: u = parent[v]; graph[u][v] -= path_flow; graph[v][u] += path_flow; v = parent[v]\n        max_flow += path_flow; parent = {}\n    return max_flow", "try_demo": None, "prerequisites": ["clrs_bfs"]},
    {"id": "clrs_bipartite_matching", "book_id": "clrs_graph", "level": "expert", "title": "Maximum Bipartite Matching (Ch 26.3)", "learn": "Maximum matching in bipartite graph. Reduce to max flow: add source/sink, unit capacities. Matching = flow. Applications: job assignment, stable marriage. O(VE) with max flow.", "try_code": "def max_bipartite_matching(left, right, edges):\n    graph = {}; source, sink = 'source', 'sink'\n    graph[source] = {u: 1 for u in left}\n    for u in left:\n        graph[u] = {}\n        for v in edges.get(u, []): graph[u][v] = 1\n    for v in right:\n        if v not in graph: graph[v] = {}\n        graph[v][sink] = 1\n    graph[sink] = {}\n    # Run max flow\n    matching = 0\n    # ... simplified for brevity\n    return matching\nleft = ['A1', 'A2', 'A3']; right = ['B1', 'B2', 'B3']\nedges = {'A1': ['B1', 'B2'], 'A2': ['B2'], 'A3': ['B2', 'B3']}", "try_demo": None, "prerequisites": ["clrs_max_flow"]},
    
    # DATA STRUCTURES (5)
    {"id": "clrs_heap", "book_id": "clrs_data_structures", "level": "basics", "title": "Binary Heap (Ch 6)", "learn": "Complete binary tree with heap property. Max-heap: parent ≥ children. Operations: insert O(log n), extract-max O(log n), heapify O(n). Used in heapsort, priority queues.", "try_code": "class MaxHeap:\n    def __init__(self): self.heap = []\n    def parent(self, i): return (i - 1) // 2\n    def left(self, i): return 2 * i + 1\n    def right(self, i): return 2 * i + 2\n    def insert(self, key): self.heap.append(key); self._sift_up(len(self.heap) - 1)\n    def _sift_up(self, i):\n        while i > 0 and self.heap[self.parent(i)] < self.heap[i]:\n            p = self.parent(i); self.heap[i], self.heap[p] = self.heap[p], self.heap[i]; i = p\n    def extract_max(self):\n        if not self.heap: return None\n        max_val = self.heap[0]; self.heap[0] = self.heap[-1]; self.heap.pop()\n        if self.heap: self._sift_down(0)\n        return max_val\n    def _sift_down(self, i):\n        max_idx = i; l, r = self.left(i), self.right(i)\n        if l < len(self.heap) and self.heap[l] > self.heap[max_idx]: max_idx = l\n        if r < len(self.heap) and self.heap[r] > self.heap[max_idx]: max_idx = r\n        if max_idx != i: self.heap[i], self.heap[max_idx] = self.heap[max_idx], self.heap[i]; self._sift_down(max_idx)\nheap = MaxHeap()\nfor x in [3, 1, 6, 5, 2, 4]: heap.insert(x)\nprint(heap.extract_max())", "try_demo": None, "prerequisites": []},
    {"id": "clrs_hash_table", "book_id": "clrs_data_structures", "level": "basics", "title": "Hash Tables (Ch 11)", "learn": "Array-based dictionary with hash function. Collision resolution: chaining or open addressing. Expected O(1) operations. Load factor α = n/m affects performance.", "try_code": "class HashTable:\n    def __init__(self, size=10): self.size = size; self.table = [[] for _ in range(size)]\n    def hash(self, key): return hash(key) % self.size\n    def insert(self, key, value):\n        idx = self.hash(key)\n        for i, (k, v) in enumerate(self.table[idx]):\n            if k == key: self.table[idx][i] = (key, value); return\n        self.table[idx].append((key, value))\n    def get(self, key):\n        idx = self.hash(key)\n        for k, v in self.table[idx]:\n            if k == key: return v\n        return None\nht = HashTable()\nht.insert('name', 'Alice'); ht.insert('age', 30)\nprint(ht.get('name'))", "try_demo": None, "prerequisites": []},
    {"id": "clrs_bst", "book_id": "clrs_data_structures", "level": "intermediate", "title": "Binary Search Tree (Ch 12)", "learn": "Binary tree with BST property: left < node < right. Operations: search, insert, delete O(h) where h=height. Inorder traversal yields sorted sequence. Can degenerate to O(n).", "try_code": "class TreeNode:\n    def __init__(self, key): self.key = key; self.left = self.right = None\nclass BST:\n    def __init__(self): self.root = None\n    def insert(self, key): self.root = self._insert(self.root, key)\n    def _insert(self, node, key):\n        if not node: return TreeNode(key)\n        if key < node.key: node.left = self._insert(node.left, key)\n        else: node.right = self._insert(node.right, key)\n        return node\n    def inorder(self):\n        result = []\n        def traverse(node):\n            if node: traverse(node.left); result.append(node.key); traverse(node.right)\n        traverse(self.root)\n        return result\nbst = BST()\nfor x in [5, 3, 7, 1, 9]: bst.insert(x)\nprint(bst.inorder())", "try_demo": None, "prerequisites": ["clrs_heap"]},
    {"id": "clrs_rbt", "book_id": "clrs_data_structures", "level": "advanced", "title": "Red-Black Trees (Ch 13)", "learn": "Self-balancing BST with color property. Guarantees O(log n) operations. Properties: root black, red nodes have black children, black-height uniform. Rotations maintain balance.", "try_code": "class RBNode:\n    def __init__(self, key, color='red'):\n        self.key = key; self.color = color; self.left = self.right = self.parent = None\nclass RedBlackTree:\n    def __init__(self): self.NIL = RBNode(None, 'black'); self.root = self.NIL\n    def left_rotate(self, x):\n        y = x.right; x.right = y.left\n        if y.left != self.NIL: y.left.parent = x\n        y.parent = x.parent\n        if x.parent == None: self.root = y\n        elif x == x.parent.left: x.parent.left = y\n        else: x.parent.right = y\n        y.left = x; x.parent = y\n# RBT guarantees O(log n) height", "try_demo": None, "prerequisites": ["clrs_bst"]},
    {"id": "clrs_btree", "book_id": "clrs_data_structures", "level": "expert", "title": "B-Trees (Ch 18)", "learn": "Generalized BST for disk storage. Node has multiple keys (min degree t). Height O(log_t n). All leaves at same level. Operations: search, insert, split. Used in databases, filesystems.", "try_code": "class BTreeNode:\n    def __init__(self, t, leaf=True):\n        self.t = t; self.keys = []; self.children = []; self.leaf = leaf\n    def search(self, key):\n        i = 0\n        while i < len(self.keys) and key > self.keys[i]: i += 1\n        if i < len(self.keys) and key == self.keys[i]: return self\n        if self.leaf: return None\n        return self.children[i].search(key)\nclass BTree:\n    def __init__(self, t): self.root = BTreeNode(t); self.t = t\n    def search(self, key): return self.root.search(key)\n# B-Tree with minimum degree 3 (each node has 2-5 keys)", "try_demo": None, "prerequisites": ["clrs_rbt"]},
    
    # NP-COMPLETENESS (3)
    {"id": "clrs_np_intro", "book_id": "clrs_complexity", "level": "intermediate", "title": "P, NP, NP-Complete (Ch 34.1-34.3)", "learn": "P: polynomial-time solvable. NP: polynomial-time verifiable. NP-complete: hardest in NP, all reduce to each other. Cook-Levin: SAT is NP-complete. P=NP? unsolved.", "try_code": "def verify_hamiltonian_path(graph, path):\n    n = len(path)\n    if n != len(graph): return False\n    if len(set(path)) != n: return False\n    for i in range(n - 1):\n        if path[i+1] not in graph[path[i]]: return False\n    return True\ngraph = {0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2]}\npath = [0, 1, 3, 2]\nprint(verify_hamiltonian_path(graph, path))", "try_demo": None, "prerequisites": []},
    {"id": "clrs_reductions", "book_id": "clrs_complexity", "level": "advanced", "title": "Polynomial-Time Reductions (Ch 34.4)", "learn": "Reduce problem A to B: solve A using B solver. If A reduces to B and B ∈ P, then A ∈ P. NP-completeness proofs: reduce known NP-complete to new problem. Examples: SAT → 3-SAT → CLIQUE.", "try_code": "# Example reduction: VERTEX-COVER ≤_P SET-COVER\ndef vertex_cover_to_set_cover(graph, k):\n    universe = set(range(len(graph.edges)))\n    subsets = {}\n    for vertex in range(len(graph.vertices)):\n        subsets[vertex] = {e for e, (u, v) in enumerate(graph.edges) if u == vertex or v == vertex}\n    return universe, subsets, k\n# If we could solve set-cover in poly time, we could solve vertex-cover\n# Since vertex-cover is NP-complete, set-cover is too", "try_demo": None, "prerequisites": ["clrs_np_intro"]},
    {"id": "clrs_approximation", "book_id": "clrs_complexity", "level": "expert", "title": "Approximation Algorithms (Ch 35)", "learn": "For NP-hard optimization, find near-optimal solution in poly time. ρ-approximation: cost ≤ ρ·OPT. Examples: vertex cover (2-approx), TSP metric (2-approx), set cover (ln n-approx).", "try_code": "def vertex_cover_approx(edges):\n    cover = set(); uncovered = set(edges)\n    while uncovered:\n        u, v = uncovered.pop(); cover.add(u); cover.add(v)\n        uncovered = {(a, b) for a, b in uncovered if a != u and a != v and b != u and b != v}\n    return cover\nedges = [(0,1), (1,2), (2,3), (0,3), (1,3)]\ncover = vertex_cover_approx(edges)\nprint(f'Approx vertex cover (size={len(cover)}): {cover}')", "try_demo": None, "prerequisites": ["clrs_reductions"]},
]


def get_curriculum() -> List[Dict[str, Any]]:
    return list(CURRICULUM)


def get_books() -> List[Dict[str, Any]]:
    return list(BOOKS)


def get_levels() -> List[str]:
    return list(LEVELS)


def get_by_book(book_id: str) -> List[Dict[str, Any]]:
    return [c for c in CURRICULUM if c["book_id"] == book_id]


def get_by_level(level: str) -> List[Dict[str, Any]]:
    return [c for c in CURRICULUM if c["level"] == level]


def get_item(item_id: str) -> Dict[str, Any] | None:
    for c in CURRICULUM:
        if c["id"] == item_id:
            return c
    return None
